{"version":3,"sources":["pages-manifest-plugin.js"],"names":["PagesManifestPlugin","apply","compiler","hooks","emit","tap","compilation","chunks","pages","chunk","result","ROUTE_NAME_REGEX","exec","name","pagePath","replace","push","assets","PAGES_MANIFEST","RawSource","JSON","stringify"],"mappings":"4DAAA,+CACA,8CAMA;AACA;AACA;AACe,KAAMA,CAAAA,mBAAoB,CACvCC,KAAK,CAACC,QAAD,CAAW,CACdA,QAAQ,CAACC,KAAT,CAAeC,IAAf,CAAoBC,GAApB,CAAwB,oBAAxB,CAA+CC,WAAD,EAAiB,CAC7D,KAAM,CAAEC,MAAF,EAAaD,WAAnB,CACA,KAAME,CAAAA,KAAK,CAAG,EAAd,CAEA,IAAK,KAAMC,CAAAA,KAAX,GAAoBF,CAAAA,MAApB,CAA4B,CAC1B,KAAMG,CAAAA,MAAM,CAAGC,4BAAiBC,IAAjB,CAAsBH,KAAK,CAACI,IAA5B,CAAf,CAEA,GAAI,CAACH,MAAL,CAAa,CACX,SACD,CAED,KAAMI,CAAAA,QAAQ,CAAGJ,MAAM,CAAC,CAAD,CAAvB,CAEA,GAAI,CAACI,QAAL,CAAe,CACb,SACD,CACD,GAAIN,KAAK,CAAE,IAAGM,QAAQ,CAACC,OAAT,CAAiB,KAAjB,CAAwB,GAAxB,CAA6B,EAAlC,CAAT,CAA+C,CAC7CP,KAAK,CAAE,IAAGM,QAAQ,CAACC,OAAT,CAAiB,KAAjB,CAAwB,GAAxB,CAA6B,EAAlC,CAAL,CAA0CC,IAA1C,CAA+CP,KAAK,CAACI,IAAN,CAAWE,OAAX,CAC7C,KAD6C,CAE7C,GAF6C,EAG3C,KAHJ,EAID,CALD,IAKO,CACLP,KAAK,CAAE,IAAGM,QAAQ,CAACC,OAAT,CAAiB,KAAjB,CAAwB,GAAxB,CAA6B,EAAlC,CAAL,CAA4C,CAACN,KAAK,CAACI,IAAN,CAAWE,OAAX,CAC3C,KAD2C,CAE3C,GAF2C,EAGzC,KAHwC,CAA5C,CAKD,CACF,CAED,GAAI,MAAOP,CAAAA,KAAK,CAAC,QAAD,CAAZ,GAA2B,WAA/B,CAA4C,CAC1CA,KAAK,CAAC,GAAD,CAAL,CAAaA,KAAK,CAAC,QAAD,CAAlB,CACD,CAEDF,WAAW,CAACW,MAAZ,CAAmBC,yBAAnB,EAAqC,GAAIC,0BAAJ,CAAcC,IAAI,CAACC,SAAL,CAAeb,KAAf,CAAd,CAArC,CACD,CAnCD,EAoCD,CAtCsC,C","sourcesContent":["import { RawSource } from 'webpack-sources'\nimport {\n  PAGES_MANIFEST,\n  ROUTE_NAME_REGEX,\n  SERVERLESS_ROUTE_NAME_REGEX,\n} from '../../lib/constants'\n\n// This plugin creates a pages-manifest.json from page entrypoints.\n// This is used for mapping paths like `/` to `.next/server/static/<buildid>/pages/index.js` when doing SSR\n// It's also used by next export to provide defaultPathMap\nexport default class PagesManifestPlugin {\n  apply(compiler) {\n    compiler.hooks.emit.tap('HachiPagesManifest', (compilation) => {\n      const { chunks } = compilation\n      const pages = {}\n      \n      for (const chunk of chunks) {\n        const result = ROUTE_NAME_REGEX.exec(chunk.name)\n\n        if (!result) {\n          continue\n        }\n\n        const pagePath = result[1]\n\n        if (!pagePath) {\n          continue\n        }\n        if (pages[`/${pagePath.replace(/\\\\/g, '/')}`]) {\n          pages[`/${pagePath.replace(/\\\\/g, '/')}`].push(chunk.name.replace(\n            /\\\\/g,\n            '/'\n          ) + '.js')\n        } else {\n          pages[`/${pagePath.replace(/\\\\/g, '/')}`] = [chunk.name.replace(\n            /\\\\/g,\n            '/'\n          ) + '.js'];\n\n        }\n      }\n\n      if (typeof pages['/index'] !== 'undefined') {\n        pages['/'] = pages['/index']\n      }\n\n      compilation.assets[PAGES_MANIFEST] = new RawSource(JSON.stringify(pages))\n    })\n  }\n}\n"]}